<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Voxel Engine 2.0</title>
<style>
body { margin:0; overflow:hidden; background:black; }
#crosshair{
position:fixed;
top:50%;left:50%;
width:6px;height:6px;
margin-left:-3px;margin-top:-3px;
background:white;
pointer-events:none;
}
</style>
</head>
<body>

<div id="crosshair"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>

<script>
/* ===========================
   BASIC SETUP
=========================== */

let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(
75, window.innerWidth/window.innerHeight, 0.1, 1000
);
let renderer = new THREE.WebGLRenderer({antialias:false});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

let clock = new THREE.Clock();

scene.background = new THREE.Color(0x87CEEB);

let sun = new THREE.DirectionalLight(0xffffff,1);
sun.position.set(100,200,100);
scene.add(sun);
scene.add(new THREE.AmbientLight(0x404040));

/* ===========================
   TEXTURE ATLAS
=========================== */

const TILE_SIZE = 16;
const ATLAS_SIZE = 256;
const TILE_UV = TILE_SIZE / ATLAS_SIZE;

// Skapa en fallback-texture om atlas.png inte finns
let canvas = document.createElement('canvas');
canvas.width = 256;
canvas.height = 256;
let ctx = canvas.getContext('2d');
ctx.fillStyle = '#654321';
ctx.fillRect(0,0,256,256);
ctx.fillStyle = '#228B22';
ctx.fillRect(16,0,16,16);
ctx.fillStyle = '#8B4513';
ctx.fillRect(0,0,16,16);

let texture = new THREE.CanvasTexture(canvas);
texture.magFilter = THREE.NearestFilter;
texture.minFilter = THREE.NearestFilter;

// Försök ladda atlas.png om den finns
new THREE.TextureLoader().load("atlas.png", 
    function(tex) {
        texture.image = tex.image;
        texture.needsUpdate = true;
    },
    undefined,
    function(err) {
        console.log("Använder fallback-texture");
    }
);

let material = new THREE.MeshLambertMaterial({ map: texture });

function getUV(tileX, tileY){
    let u = tileX * TILE_UV;
    let v = 1 - (tileY + 1) * TILE_UV;
    return [
        u, v + TILE_UV,  // 0,0
        u + TILE_UV, v + TILE_UV,  // 1,0
        u + TILE_UV, v,  // 1,1
        u, v   // 0,1
    ];
}

/* ===========================
   PLAYER
=========================== */

let velocity = new THREE.Vector3();
let keys = {};
let canJump = false;

camera.position.set(0,40,0);

document.body.onclick = ()=> document.body.requestPointerLock();

document.addEventListener("mousemove",e=>{
if(document.pointerLockElement===document.body){
camera.rotation.y -= e.movementX*0.002;
camera.rotation.x -= e.movementY*0.002;
camera.rotation.x = Math.max(-1.5,Math.min(1.5,camera.rotation.x));
}
});

document.addEventListener("keydown",e=>keys[e.code]=true);
document.addEventListener("keyup",e=>keys[e.code]=false);

/* ===========================
   ENGINE CORE
=========================== */

const CHUNK_SIZE=16;
const CHUNK_HEIGHT=32;
const RENDER_DISTANCE=2;

let chunks=new Map();

class Chunk{

constructor(cx,cz){
this.cx=cx;
this.cz=cz;
this.voxels=new Uint8Array(CHUNK_SIZE*CHUNK_HEIGHT*CHUNK_SIZE);
this.mesh=null;
this.generate();
this.buildMesh();
}

index(x,y,z){
return x + CHUNK_SIZE*(z + CHUNK_SIZE*y);
}

get(x,y,z){
if(x<0||y<0||z<0||x>=CHUNK_SIZE||y>=CHUNK_HEIGHT||z>=CHUNK_SIZE)
return 0;
return this.voxels[this.index(x,y,z)];
}

set(x,y,z,v){
this.voxels[this.index(x,y,z)]=v;
}

generate(){
for(let x=0;x<CHUNK_SIZE;x++){
for(let z=0;z<CHUNK_SIZE;z++){

let worldX=this.cx*CHUNK_SIZE+x;
let worldZ=this.cz*CHUNK_SIZE+z;

let height=Math.floor(
8 + Math.sin(worldX*0.1)*3 +
Math.cos(worldZ*0.1)*3
);

for(let y=0;y<height;y++){
if(y===height-1) this.set(x,y,z,1);
else this.set(x,y,z,2);
}
}
}
}

buildMesh(){

if(this.mesh) {
    scene.remove(this.mesh);
    this.mesh.geometry.dispose();
}

let positions=[];
let uvs=[];
let indices=[];
let face=0;

const faces=[
{dir:[0,1,0],  corners:[[0,1,0],[1,1,0],[1,1,1],[0,1,1]], uvOrder:[0,1,2,3]},
{dir:[0,-1,0], corners:[[0,0,1],[1,0,1],[1,0,0],[0,0,0]], uvOrder:[0,1,2,3]},
{dir:[1,0,0],  corners:[[1,0,1],[1,1,1],[1,1,0],[1,0,0]], uvOrder:[0,1,2,3]},
{dir:[-1,0,0], corners:[[0,0,0],[0,1,0],[0,1,1],[0,0,1]], uvOrder:[0,1,2,3]},
{dir:[0,0,1],  corners:[[0,0,1],[0,1,1],[1,1,1],[1,0,1]], uvOrder:[0,1,2,3]},
{dir:[0,0,-1], corners:[[1,0,0],[1,1,0],[0,1,0],[0,0,0]], uvOrder:[0,1,2,3]},
];

for(let x=0;x<CHUNK_SIZE;x++){
for(let y=0;y<CHUNK_HEIGHT;y++){
for(let z=0;z<CHUNK_SIZE;z++){

let block=this.get(x,y,z);
if(!block) continue;

for(let f of faces){

let nx=x+f.dir[0];
let ny=y+f.dir[1];
let nz=z+f.dir[2];

if(this.get(nx,ny,nz)) continue;

let wx=this.cx*CHUNK_SIZE+x;
let wz=this.cz*CHUNK_SIZE+z;

for(let c of f.corners){
positions.push(wx+c[0],y+c[1],wz+c[2]);
}

let tileX = block===1 ? 0 : 1;
let tileY = 0;

let uv=getUV(tileX,tileY);

// Korrekt UV-mappning för varje hörn
uvs.push(uv[0], uv[1]);  // hörn 0
uvs.push(uv[2], uv[3]);  // hörn 1
uvs.push(uv[4], uv[5]);  // hörn 2
uvs.push(uv[6], uv[7]);  // hörn 3

indices.push(
face*4+0,face*4+1,face*4+2,
face*4+0,face*4+2,face*4+3
);

face++;
}
}
}
}

if(positions.length === 0) return;

let geo=new THREE.BufferGeometry();
geo.setAttribute("position",
new THREE.Float32BufferAttribute(positions,3));
geo.setAttribute("uv",
new THREE.Float32BufferAttribute(uvs,2));
geo.setIndex(indices);
geo.computeVertexNormals();

this.mesh=new THREE.Mesh(geo,material);
scene.add(this.mesh);
}

}

/* ===========================
   CHUNK STREAMING
=========================== */

function updateChunks(){

let cx=Math.floor(camera.position.x/CHUNK_SIZE);
let cz=Math.floor(camera.position.z/CHUNK_SIZE);

for(let dx=-RENDER_DISTANCE;dx<=RENDER_DISTANCE;dx++){
for(let dz=-RENDER_DISTANCE;dz<=RENDER_DISTANCE;dz++){

let key=`${cx+dx},${cz+dz}`;

if(!chunks.has(key)){
chunks.set(key,new Chunk(cx+dx,cz+dz));
}
}
}

for(let key of chunks.keys()){
let [x,z]=key.split(",").map(Number);
if(Math.abs(x-cx)>RENDER_DISTANCE+1||
Math.abs(z-cz)>RENDER_DISTANCE+1){
let chunk = chunks.get(key);
if(chunk.mesh) scene.remove(chunk.mesh);
chunks.delete(key);
}
}
}

/* ===========================
   PLAYER UPDATE
=========================== */

function updatePlayer(delta){

velocity.x-=velocity.x*10*delta;
velocity.z-=velocity.z*10*delta;

// Rörelse relativt kamerans riktning
let speed = 30;
if(keys["KeyW"]) velocity.z-=speed*delta;
if(keys["KeyS"]) velocity.z+=speed*delta;
if(keys["KeyA"]) velocity.x-=speed*delta;
if(keys["KeyD"]) velocity.x+=speed*delta;

camera.translateX(velocity.x*delta);
camera.translateZ(velocity.z*delta);

// Enkel gravitation
velocity.y-=40*delta;
camera.position.y+=velocity.y*delta;

// Markkollision (enkel)
if(camera.position.y<12){
velocity.y=0;
camera.position.y=12;
canJump=true;
}

if(keys["Space"]&&canJump){
velocity.y=15;
canJump=false;
}
}

/* ===========================
   LOOP
=========================== */

function animate(){
requestAnimationFrame(animate);
let delta=Math.min(clock.getDelta(), 0.1); // Cap delta för att undvika hopp
updatePlayer(delta);
updateChunks();
renderer.render(scene,camera);
}

animate();
</script>
</body>
</html>
