<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Voxel Engine 2.0</title>
<style>
body { margin:0; overflow:hidden; background:black; }
#crosshair{
position:fixed;
top:50%;left:50%;
width:6px;height:6px;
margin-left:-3px;margin-top:-3px;
background:white;
pointer-events:none;
z-index:1000;
}
#debug{
position:fixed;
top:10px;left:10px;
color:white;
font-family:monospace;
background:rgba(0,0,0,0.5);
padding:10px;
}
</style>
</head>
<body>

<div id="crosshair"></div>
<div id="debug">Laddar...</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>

<script>
/* ===========================
   BASIC SETUP
=========================== */

let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(
75, window.innerWidth/window.innerHeight, 0.1, 1000
);
let renderer = new THREE.WebGLRenderer({antialias:false});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

let clock = new THREE.Clock();
let debugDiv = document.getElementById('debug');

scene.background = new THREE.Color(0x87CEEB);

// Ljus
let sun = new THREE.DirectionalLight(0xffffff, 1.0);
sun.position.set(50, 100, 50);
scene.add(sun);
scene.add(new THREE.AmbientLight(0x888888));

/* ===========================
   TEXTURE - ENKEL FALLBACK
=========================== */

const TILE_SIZE = 16;
const ATLAS_SIZE = 256;
const TILE_UV = TILE_SIZE / ATLAS_SIZE;

// Skapa enkel canvas texture
let canvas = document.createElement('canvas');
canvas.width = 256;
canvas.height = 256;
let ctx = canvas.getContext('2d');

// Rensa och fyll med färger
ctx.fillStyle = '#FF00FF';
ctx.fillRect(0, 0, 256, 256);

// Gräs (0,0)
ctx.fillStyle = '#00AA00';
ctx.fillRect(0, 0, 16, 16);
ctx.fillStyle = '#8B4513';
ctx.fillRect(0, 12, 16, 4);

// Jord (1,0)
ctx.fillStyle = '#8B4513';
ctx.fillRect(16, 0, 16, 16);

// Sten (2,0)
ctx.fillStyle = '#888888';
ctx.fillRect(32, 0, 16, 16);

let texture = new THREE.CanvasTexture(canvas);
texture.magFilter = THREE.NearestFilter;
texture.minFilter = THREE.NearestFilter;

let material = new THREE.MeshLambertMaterial({ map: texture });

function getUV(tileX, tileY){
    let u = tileX * TILE_UV;
    let v = 1 - (tileY + 1) * TILE_UV;
    return [
        u, v + TILE_UV,
        u + TILE_UV, v + TILE_UV,
        u + TILE_UV, v,
        u, v
    ];
}

/* ===========================
   PLAYER
=========================== */

let velocity = new THREE.Vector3();
let keys = {};
let canJump = false;

// Starta högt upp och titta neråt
camera.position.set(8, 50, 8);
camera.lookAt(8, 0, 8);

document.body.onclick = ()=> document.body.requestPointerLock();

document.addEventListener("mousemove",e=>{
if(document.pointerLockElement===document.body){
camera.rotation.y -= e.movementX*0.002;
camera.rotation.x -= e.movementY*0.002;
camera.rotation.x = Math.max(-1.5,Math.min(1.5,camera.rotation.x));
}
});

document.addEventListener("keydown",e=>keys[e.code]=true);
document.addEventListener("keyup",e=>keys[e.code]=false);

/* ===========================
   CHUNK SYSTEM
=========================== */

const CHUNK_SIZE = 16;
const CHUNK_HEIGHT = 32;

class Chunk {
    constructor(cx, cz) {
        this.cx = cx;
        this.cz = cz;
        this.voxels = new Uint8Array(CHUNK_SIZE * CHUNK_HEIGHT * CHUNK_SIZE);
        this.mesh = null;
        this.generate();
        this.buildMesh();
    }

    index(x, y, z) {
        return x + CHUNK_SIZE * (z + CHUNK_SIZE * y);
    }

    get(x, y, z) {
        if(x<0 || y<0 || z<0 || x>=CHUNK_SIZE || y>=CHUNK_HEIGHT || z>=CHUNK_SIZE)
            return 0;
        return this.voxels[this.index(x,y,z)];
    }

    set(x, y, z, v) {
        this.voxels[this.index(x,y,z)] = v;
    }

    generate() {
        for(let x=0; x<CHUNK_SIZE; x++) {
            for(let z=0; z<CHUNK_SIZE; z++) {
                let worldX = this.cx * CHUNK_SIZE + x;
                let worldZ = this.cz * CHUNK_SIZE + z;
                
                // Enkel höjdgenerering
                let height = Math.floor(8 + Math.sin(worldX*0.1)*3 + Math.cos(worldZ*0.1)*3);
                
                for(let y=0; y<height && y<CHUNK_HEIGHT; y++) {
                    if(y === height-1) this.set(x,y,z,1); // Gräs
                    else if(y > height-4) this.set(x,y,z,2); // Jord
                    else this.set(x,y,z,3); // Sten
                }
            }
        }
    }

    buildMesh() {
        if(this.mesh) {
            scene.remove(this.mesh);
            this.mesh.geometry.dispose();
        }

        let positions = [];
        let uvs = [];
        let indices = [];
        let faceCount = 0;

        // 6 riktningar: +Y, -Y, +X, -X, +Z, -Z
        const dirs = [
            [0,1,0], [0,-1,0], [1,0,0], [-1,0,0], [0,0,1], [0,0,-1]
        ];
        
        // Hörn för varje riktning (4 hörn per face)
        const corners = [
            [[0,1,0],[1,1,0],[1,1,1],[0,1,1]], // top
            [[0,0,1],[1,0,1],[1,0,0],[0,0,0]], // bottom
            [[1,0,1],[1,1,1],[1,1,0],[1,0,0]], // right
            [[0,0,0],[0,1,0],[0,1,1],[0,0,1]], // left
            [[0,0,1],[0,1,1],[1,1,1],[1,0,1]], // front
            [[1,0,0],[1,1,0],[0,1,0],[0,0,0]]  // back
        ];

        for(let x=0; x<CHUNK_SIZE; x++) {
            for(let y=0; y<CHUNK_HEIGHT; y++) {
                for(let z=0; z<CHUNK_SIZE; z++) {
                    let block = this.get(x,y,z);
                    if(!block) continue;

                    for(let d=0; d<6; d++) {
                        let dir = dirs[d];
                        let nx = x + dir[0];
                        let ny = y + dir[1];
                        let nz = z + dir[2];

                        // Kolla om granne är tom
                        if(this.get(nx, ny, nz)) continue;

                        let wx = this.cx * CHUNK_SIZE + x;
                        let wz = this.cz * CHUNK_SIZE + z;

                        // Lägg till 4 hörn
                        for(let c of corners[d]) {
                            positions.push(wx + c[0], y + c[1], wz + c[2]);
                        }

                        // Välj texture
                        let tileX = 1; // default jord
                        if(block === 1) {
                            tileX = (d === 0) ? 0 : 1; // Gräs på toppen, jord på sidor
                        } else if(block === 3) {
                            tileX = 2; // Sten
                        }

                        let uv = getUV(tileX, 0);
                        
                        // 4 hörn, 2 UVs per hörn
                        uvs.push(uv[0], uv[1]);
                        uvs.push(uv[2], uv[3]);
                        uvs.push(uv[4], uv[5]);
                        uvs.push(uv[6], uv[7]);

                        // 2 trianglar = 6 indices
                        let base = faceCount * 4;
                        indices.push(base, base+1, base+2, base, base+2, base+3);
                        
                        faceCount++;
                    }
                }
            }
        }

        if(positions.length === 0) {
            console.log("Inga faces genererade för chunk", this.cx, this.cz);
            return;
        }

        console.log("Chunk", this.cx, this.cz, "faces:", faceCount, "verts:", positions.length/3);

        let geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        geo.setIndex(indices);
        geo.computeVertexNormals();

        this.mesh = new THREE.Mesh(geo, material);
        scene.add(this.mesh);
    }
}

/* ===========================
   MAIN
=========================== */

// Skapa en chunk vid 0,0
let chunk = new Chunk(0, 0);

// Skapa grann-chunks
new Chunk(-1, 0);
new Chunk(1, 0);
new Chunk(0, -1);
new Chunk(0, 1);

/* ===========================
   PLAYER UPDATE
=========================== */

function updatePlayer(delta) {
    // Friktion
    velocity.x -= velocity.x * 10 * delta;
    velocity.z -= velocity.z * 10 * delta;

    // Rörelse
    let speed = 50;
    if(keys["KeyW"]) velocity.z -= speed * delta;
    if(keys["KeyS"]) velocity.z += speed * delta;
    if(keys["KeyA"]) velocity.x -= speed * delta;
    if(keys["KeyD"]) velocity.x += speed * delta;

    camera.translateX(velocity.x * delta);
    camera.translateZ(velocity.z * delta);

    // Gravitation
    velocity.y -= 50 * delta;
    camera.position.y += velocity.y * delta;

    // Markkollision
    if(camera.position.y < 20) {
        velocity.y = 0;
        camera.position.y = 20;
        canJump = true;
    }

    // Hopp
    if(keys["Space"] && canJump) {
        velocity.y = 25;
        canJump = false;
    }
    
    // Uppdatera debug
    debugDiv.innerHTML = `Pos: ${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)}<br>Faces: ${chunk.mesh ? 'OK' : 'NULL'}`;
}

/* ===========================
   LOOP
=========================== */

function animate() {
    requestAnimationFrame(animate);
    let delta = Math.min(clock.getDelta(), 0.1);
    updatePlayer(delta);
    renderer.render(scene, camera);
}

animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
